class generator:
    topic_type = {}
    publisher = {}
    subscriber = {}

    def __init__(self, types=None, publishers=None, subscribers=None):
        self.topic_type = types[0]
        self.publisher = publishers[0]
        self.subscriber = subscribers[0]

    def make_topic(self, topic):
        structName = topic.get('struct')
        members = topic.get('member')
        MAX_NAME_LEN = topic.get('MAX_NAME_LEN')
        MAX_MSG_LEN = topic.get('MAX_MSG_LEN')

    def make_pub(self):
        sb = '\n'
        sb += '#include <ace/Log_Msg.h>\n'
        sb += '#include <dds/DdsDcpsInfrastructureC.h>\n'
        sb += '#include <dds/DdsDcpsPublicationC.h>\n'
        sb += '#include <dds/DCPS/Marked_Default_Qos.h>\n'
        sb += '#include <dds/DCPS/Service_Participant.h>\n'
        sb += '#include <dds/DCPS/WaitSet.h>\n'
        sb += '#include "dds/DCPS/StaticIncludes.h"\n'
        sb += '#include "' + self.publisher.get("topic") + 'TypeSupportImpl.h"\n'
        sb += '\n'
        sb += 'int\n'
        sb += 'ACE_TMAIN(int argc, ACE_TCHAR *argv[])\n'
        sb += '{\n'
        sb += '  try {\n'
        sb += '    // Initialize DomainParticipantFactory\n'
        sb += '    DDS::DomainParticipantFactory_var dpf =\n'
        sb += '      TheParticipantFactoryWithArgs(argc, argv);\n'
        sb += '\n'
        sb += '    // Create DomainParticipant\n'
        sb += '    DDS::DomainParticipant_var participant =\n'
        sb += '      dpf->create_participant(42,\n'
        sb += '                              PARTICIPANT_QOS_DEFAULT,\n'
        sb += '                              0,\n'
        sb += '                              OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!participant) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_participant failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Register TypeSupport (Messenger::Message)\n'
        sb += '    ' + self.topic_type.get("struct") + '::' + self.publisher.get("topic") + 'TypeSupport_var ts =\n'
        sb += '      new ' + self.topic_type.get("struct") + '::' + self.publisher.get("topic") + 'TypeSupportImpl;\n'
        sb += '\n'
        sb += '    if (ts->register_type(participant, "") != DDS::RETCODE_OK) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" register_type failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Create Topic (Movie Discussion List)\n'
        sb += '    CORBA::String_var type_name = ts->get_type_name();\n'
        sb += '    DDS::Topic_var topic =\n'
        sb += '      participant->create_topic("' + str(self.publisher.get("msg")) + '",\n'
        sb += '                                type_name,\n'
        sb += '                                TOPIC_QOS_DEFAULT,\n'
        sb += '                                0,\n'
        sb += '                                OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!topic) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_topic failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Create Publisher\n'
        sb += '    DDS::Publisher_var publisher =\n'
        sb += '      participant->create_publisher(PUBLISHER_QOS_DEFAULT,\n'
        sb += '                                    0,\n'
        sb += '                                    OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!publisher) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_publisher failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Create DataWriter\n'
        sb += '    DDS::DataWriter_var writer =\n'
        sb += '      publisher->create_datawriter(topic,\n'
        sb += '                                   DATAWRITER_QOS_DEFAULT,\n'
        sb += '                                   0,\n'
        sb += '                                   OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!writer) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_datawriter failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    ' + self.topic_type.get("struct") + '::' + self.publisher.get(
            "topic") + 'DataWriter_var ' + self.publisher.get("topic") + '_writer =\n'
        sb += '      ' + self.topic_type.get("struct") + '::' + self.publisher.get(
            "topic") + 'DataWriter::_narrow(writer);\n'
        sb += '\n'
        sb += '    if (!' + self.publisher.get("topic") + '_writer) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" _narrow failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Block until Subscriber is available\n'
        sb += '    DDS::StatusCondition_var condition = writer->get_statuscondition();\n'
        sb += '    condition->set_enabled_statuses(DDS::PUBLICATION_MATCHED_STATUS);\n'
        sb += '\n'
        sb += '    DDS::WaitSet_var ws = new DDS::WaitSet;\n'
        sb += '    ws->attach_condition(condition);\n'
        sb += '\n'
        sb += '    while (true) {\n'
        sb += '      DDS::PublicationMatchedStatus matches;\n'
        sb += '      if (writer->get_publication_matched_status(matches) != ::DDS::RETCODE_OK) {\n'
        sb += '        ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                          ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                          ACE_TEXT(" get_publication_matched_status failed!\\n")),\n'
        sb += '                         -1);\n'
        sb += '      }\n'
        sb += '\n'
        sb += '      if (matches.current_count >= 1) {\n'
        sb += '        break;\n'
        sb += '      }\n'
        sb += '\n'
        sb += '      DDS::ConditionSeq conditions;\n'
        sb += '      DDS::Duration_t timeout = { 60, 0 };\n'
        sb += '      if (ws->wait(conditions, timeout) != DDS::RETCODE_OK) {\n'
        sb += '        ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                          ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                          ACE_TEXT(" wait failed!\\n")),\n'
        sb += '                         -1);\n'
        sb += '      }\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    ws->detach_condition(condition);\n'
        sb += '\n'
        sb += '    // Write samples\n'
        sb += '    ' + self.topic_type.get("struct") + '::' + self.publisher.get("topic") + ' ' + self.publisher.get(
            "topic") + ';\n'
        sb += '    ' + self.publisher.get("topic") + '.subject_id = 99;\n'
        sb += '\n'
        sb += '    ' + self.publisher.get("topic") + '.from       = "Comic Book Guy";\n'
        sb += '    ' + self.publisher.get("topic") + '.subject    = "Review";\n'
        sb += '    ' + self.publisher.get("topic") + '.text       = "Worst. Movie. Ever.";\n'
        sb += '    ' + self.publisher.get("topic") + '.count      = 0;\n'
        sb += '\n'
        sb += '    for (int i = 0; i < 10; ++i) {\n'
        sb += '      DDS::ReturnCode_t error = ' + self.publisher.get("topic") + '_writer->write(' + self.publisher.get(
            "topic") + ', DDS::HANDLE_NIL);\n'
        sb += '      ++' + self.publisher.get("topic") + '.count;\n'
        sb += '      ++' + self.publisher.get("topic") + '.subject_id;\n'
        sb += '\n'
        sb += '      if (error != DDS::RETCODE_OK) {\n'
        sb += '        ACE_ERROR((LM_ERROR,\n'
        sb += '                   ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                   ACE_TEXT(" write returned %d!\\n"), error));\n'
        sb += '      }\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Wait for samples to be acknowledged\n'
        sb += '    DDS::Duration_t timeout = { 30, 0 };\n'
        sb += '    if (' + self.publisher.get(
            "topic") + '_writer->wait_for_acknowledgments(timeout) != DDS::RETCODE_OK) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" wait_for_acknowledgments failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Clean-up!\n'
        sb += '    participant->delete_contained_entities();\n'
        sb += '    dpf->delete_participant(participant);\n'
        sb += '\n'
        sb += '    TheServiceParticipant->shutdown();\n'
        sb += '\n'
        sb += '  } catch (const CORBA::Exception& e) {\n'
        sb += '    e._tao_print_exception("Exception caught in main():");\n'
        sb += '    return -1;\n'
        sb += '  }\n'
        sb += '\n'
        sb += '  return 0;\n'
        sb += '}\n'
        sb += '\n'
        name = self.publisher.get('name')
        f = open('./' + name + '.cpp', 'w')
        f.write(sb)
        f.close()

    def make_sub(self):
        sb = '\n'
        sb += '#include <ace/Log_Msg.h>\n'
        sb += '#include <dds/DdsDcpsInfrastructureC.h>\n'
        sb += '#include <dds/DdsDcpsSubscriptionC.h>\n'
        sb += '#include <dds/DCPS/Marked_Default_Qos.h>\n'
        sb += '#include <dds/DCPS/Service_Participant.h>\n'
        sb += '#include <dds/DCPS/WaitSet.h>\n'
        sb += '#include "dds/DCPS/StaticIncludes.h"\n'
        sb += '#include "DataReaderListenerImpl.h"\n'
        sb += '#include "' + str(self.subscriber.get("topic")) + 'TypeSupportImpl.h"\n'
        sb += '\n'
        sb += 'int\n'
        sb += 'ACE_TMAIN(int argc, ACE_TCHAR *argv[])\n'
        sb += '{\n'
        sb += '  try {\n'
        sb += '    // Initialize DomainParticipantFactory\n'
        sb += '    DDS::DomainParticipantFactory_var dpf =\n'
        sb += '      TheParticipantFactoryWithArgs(argc, argv);\n'
        sb += '\n'
        sb += '    // Create DomainParticipant\n'
        sb += '   \n'
        sb += '    DDS::DomainParticipant_var participant =\n'
        sb += '      dpf->create_participant(42,\n'
        sb += '                              PARTICIPANT_QOS_DEFAULT,\n'
        sb += '                              0,\n'
        sb += '                              OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!participant) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_participant failed!\\n")), -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Register Type (Messenger::Message)\n'
        sb += '    ' + self.topic_type.get("struct") + '::' + self.subscriber.get("topic") + 'TypeSupport_var ts =\n'
        sb += '      new ' + self.topic_type.get("struct") + '::' + self.subscriber.get("topic") + 'TypeSupportImpl;\n'
        sb += '\n'
        sb += '    if (ts->register_type(participant, "") != DDS::RETCODE_OK) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" register_type failed!\\n")), -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Create Topic (Movie Discussion List)\n'
        sb += '    CORBA::String_var type_name = ts->get_type_name();\n'
        sb += '    DDS::Topic_var topic =\n'
        sb += '      participant->create_topic("' + self.subscriber.get("msg") + '",\n'
        sb += '                                type_name,\n'
        sb += '                                TOPIC_QOS_DEFAULT,\n'
        sb += '                                0,\n'
        sb += '                                OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!topic) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_topic failed!\\n")), -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Create Subscriber\n'
        sb += '    DDS::Subscriber_var subscriber =\n'
        sb += '      participant->create_subscriber(SUBSCRIBER_QOS_DEFAULT,\n'
        sb += '                                     0,\n'
        sb += '                                     OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!subscriber) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_subscriber failed!\\n")), -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Create DataReader\n'
        sb += '    DDS::DataReaderListener_var listener(new DataReaderListenerImpl);\n'
        sb += '\n'
        sb += '    DDS::DataReader_var reader =\n'
        sb += '      subscriber->create_datareader(topic,\n'
        sb += '                             DATAREADER_QOS_DEFAULT,\n'
        sb += '                             listener,\n'
        sb += '                             OpenDDS::DCPS::DEFAULT_STATUS_MASK);\n'
        sb += '\n'
        sb += '    if (!reader) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" create_datareader failed!\\n")), -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    ' + self.topic_type.get("struct") + '::' + self.subscriber.get("msg") + 'DataReader_var reader_i =\n'
        sb += '      ' + self.topic_type.get("struct") + '::' + self.subscriber.get(
            "msg") + 'DataReader::_narrow(reader);\n'
        sb += '\n'
        sb += '    if (!reader_i) {\n'
        sb += '      ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                        ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                        ACE_TEXT(" _narrow failed!\\n")),\n'
        sb += '                       -1);\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    // Block until Publisher completes\n'
        sb += '    DDS::StatusCondition_var condition = reader->get_statuscondition();\n'
        sb += '    condition->set_enabled_statuses(DDS::SUBSCRIPTION_MATCHED_STATUS);\n'
        sb += '\n'
        sb += '    DDS::WaitSet_var ws = new DDS::WaitSet;\n'
        sb += '    ws->attach_condition(condition);\n'
        sb += '\n'
        sb += '    while (true) {\n'
        sb += '      DDS::SubscriptionMatchedStatus matches;\n'
        sb += '      if (reader->get_subscription_matched_status(matches) != DDS::RETCODE_OK) {\n'
        sb += '        ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                          ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                          ACE_TEXT(" get_subscription_matched_status failed!\\n")), -1);\n'
        sb += '      }\n'
        sb += '\n'
        sb += '      if (matches.current_count == 0 && matches.total_count > 0) {\n'
        sb += '        break;\n'
        sb += '      }\n'
        sb += '\n'
        sb += '      DDS::ConditionSeq conditions;\n'
        sb += '      DDS::Duration_t timeout = { 60, 0 };\n'
        sb += '      if (ws->wait(conditions, timeout) != DDS::RETCODE_OK) {\n'
        sb += '        ACE_ERROR_RETURN((LM_ERROR,\n'
        sb += '                          ACE_TEXT("ERROR: %N:%l: main() -")\n'
        sb += '                          ACE_TEXT(" wait failed!\\n")), -1);\n'
        sb += '      }\n'
        sb += '    }\n'
        sb += '\n'
        sb += '    ws->detach_condition(condition);\n'
        sb += '\n'
        sb += '    // Clean-up!\n'
        sb += '    participant->delete_contained_entities();\n'
        sb += '    dpf->delete_participant(participant);\n'
        sb += '\n'
        sb += '    TheServiceParticipant->shutdown();\n'
        sb += '\n'
        sb += '  } catch (const CORBA::Exception& e) {\n'
        sb += '    e._tao_print_exception("Exception caught in main():");\n'
        sb += '    return -1;\n'
        sb += '  }\n'
        sb += '\n'
        sb += '  return 0;\n'
        sb += '}\n'
        sb += '\n'
        name = self.subscriber.get('name')
        f = open('./' + name + '.cpp', 'w')
        f.write(sb)
        f.close()